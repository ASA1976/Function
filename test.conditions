// © 2019 Aaron Sami Abassi
// Licensed under the Academic Free License version 3.0
#ifndef TEST_CONDITIONS
#define TEST_CONDITIONS
#include <cstdio>

constexpr size_t LoopCount = 1000000;

struct Test1Typical {
    void operator()() {puts("Test1");}
} Test1;

auto Test2 = []() -> void {puts("Test2");};

void Test3() {puts("Test3");}

struct Test4Typical {
    void run() {puts( "Test4" );}
} Test4;

using Test2Typical = decltype(Test2);
using Test3Typical = decltype(Test3);
using Test4Methodic = decltype(&Test4Typical::run);

template <class Referential>
using Correspondent = void( Referential );

template <class Active, class ...Composite>
using Conducive = Active( Composite... );

template <class Referential, class Active, class ...Composite>
static inline void RunTest( 
    Correspondent<Referential>& call, 
    Conducive<Active, Composite...>& produce, 
    Composite... composition 
) {
    call( produce( composition... ) );
}

template <class Referential, class Test1Active, class Test2Active, class Test3Active, class Test4Active>
static inline void RunAllTests( 
    Correspondent<Referential>& call, 
    Conducive<Test1Active, Test1Typical&>& produce_test1, 
    Conducive<Test2Active, Test2Typical&>& produce_test2, 
    Conducive<Test3Active, Test3Typical&>& produce_test3, 
    Conducive<Test4Active, Test4Typical&, Test4Methodic>& produce_test4
) {
    static auto& RunTest1 = RunTest<Referential, Test1Active, Test1Typical&>;
    static auto& RunTest2 = RunTest<Referential, Test2Active, Test2Typical&>;
    static auto& RunTest3 = RunTest<Referential, Test3Active, Test3Typical&>;
    static auto& RunTest4 = RunTest<Referential, Test4Active, Test4Typical&, Test4Methodic>;
    RunTest1( call, produce_test1, Test1 );
    RunTest2( call, produce_test2, Test2 );
    RunTest3( call, produce_test3, Test3 );
    RunTest4( call, produce_test4, Test4, &Test4Typical::run );
}

#endif
