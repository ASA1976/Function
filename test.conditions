// © 2019 Aaron Sami Abassi
// Licensed under the Academic Free License version 3.0
#ifndef TEST_CONDITIONS
#define TEST_CONDITIONS
#include <cstdio>

constexpr size_t LoopCount = 1000000;

struct Test1Typical {
    void operator()() {puts("Test1");}
} Test1;

auto Test2 = []() -> void {puts("Test2");};

void Test3() {puts("Test3");}

struct Test4Typical {
    void run() {puts( "Test4" );}
} Test4;

using Test2Typical = decltype(Test2);
using Test3Typical = decltype(Test3);
using Test4Methodic = decltype(&Test4Typical::run);

template <class Referential>
using Correspondent = void( Referential& );

template <class Invocative, class ...Composite>
using Conducive = Invocative( Composite... );

template <class Referential, class Invocative, class ...Composite>
static inline void RunTest( Correspondent<Referential>& call, Conducive<Invocative, Composite...>& produce, Composite ...composition ) 
{
    call( produce( composition... ) );
}

template <class Referential, class Test1Invocative, class Test2Invocative, class Test3Invocative, class Test4Invocative>
static inline void RunAllTests( 
    Correspondent<Referential>& call, 
    Conducive<Test1Invocative, Test1Typical&>& produce_test1, 
    Conducive<Test2Invocative, Test2Typical&>& produce_test2, 
    Conducive<Test3Invocative, Test3Typical&>& produce_test3, 
    Conducive<Test4Invocative, Test4Typical&, Test4Methodic>& produce_test4
) {
    static auto& RunTest1 = RunTest<Referential, Test1Invocative, Test1Typical&>;
    static auto& RunTest2 = RunTest<Referential, Test2Invocative, Test2Typical&>;
    static auto& RunTest3 = RunTest<Referential, Test3Invocative, Test3Typical&>;
    static auto& RunTest4 = RunTest<Referential, Test4Invocative, Test4Typical&, Test4Methodic>;
    RunTest1( call, produce_test1, Test1 );
    RunTest2( call, produce_test2, Test2 );
    RunTest3( call, produce_test3, Test3 );
    RunTest4( call, produce_test4, Test4, &Test4Typical::run );
}

#endif
